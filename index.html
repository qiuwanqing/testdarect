<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>dada01</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin: 0; background:#0b0c10; color:#e8e8e8; }
    button { font: inherit; }

    .topbar{
      position: sticky; top: 0; z-index: 10;
      display:flex; gap:8px; align-items:center;
      padding:10px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      backdrop-filter: blur(10px);
    }
    .topbar button{
      padding:8px 10px; border-radius:10px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color:#fff;
    }
    .small{ font-size:12px; opacity:.75; }

    /* 画面容器：video + overlays 都叠在这里 */
    #stage{
      position: relative;
      width: 100vw;
      height: calc(100vh - 56px);
      overflow: hidden;
      touch-action: none; /* 关键：防止浏览器把拖动当滚动 */
      background: #000;
    }

    #video{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit: cover;
      transform-origin: center;
    }

    /* 选区框（仅在拖动时显示） */
    #roiBox{
      position:absolute;
      border:0px solid rgba(255,255,255,.9);
      background: rgba(255,255,255,.08);
      border-radius: 0px;
      pointer-events:none;
      display:none;
      z-index: 5;
    }

    /* 冻结窗：一个个 canvas 叠在 video 上 */
    .freeze{
      position:absolute;
      left:0; top:0;
      border-radius: 0px;
      border: 0px solid rgba(255,255,255,.85);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      z-index: 6;
      pointer-events:none; /* 先不允许交互，保证框选好用；后面再加“点选/拖动” */
    }

    .finger {
      position: absolute;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background-color: rgba(255, 0, 0, 0);
      border: 2px solid rgba(255,255,255,.85);
      pointer-events: none;
      z-index: 7;
    }

    .hint{
      position:absolute; left:12px; bottom:12px; z-index:9;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      border-radius: 14px;
      max-width: 70vw;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <button id="btnStart">Start Camera</button>
    <button id="btnFlip">Flip</button>
    <button id="btnUndo">Undo</button>
    <button id="btnClear">Clear</button>
  </div>

  <div id="stage">
    <video id="video" playsinline muted></video>
    <div id="roiBox"></div>
  </div>

<script>
/* =========================================================
   核心思路：
   - video 始终实时播放，作为底图
   - 每次框选 ROI 后，把 video 当前帧中对应区域裁成一张“静止贴片”
   - 用一个绝对定位的 canvas 叠在 video 上，位置就是 ROI 在屏幕上的位置
========================================================= */

const stage = document.querySelector("#stage");
const video = document.querySelector("#video");
const roiBox = document.querySelector("#roiBox");

let stream = null;
let facingMode = "environment"; // "environment" | "user"
let dragging = false;
let startPt = null;
let roi = null; // {x,y,w,h} in stage CSS pixels
let freezes = []; // {el, x,y,w,h}

let fingers = []; // 用来显示手指的圆圈
let touchDistance = 0; // 两指间的距离
let touchAngle = 0; // 两指间的角度

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/**
 * 启动相机，设置视频流并开始播放
 */
async function startCamera(){
  if (!navigator.mediaDevices?.getUserMedia) {
    alert("当前浏览器不支持 getUserMedia。请用 Safari/Chrome。");
    return;
  }
  if (stream) stream.getTracks().forEach(t => t.stop());

  try{
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode },
      audio: false
    });
    video.srcObject = stream;
    await video.play();

    // 前置镜头时镜像显示（仅显示镜像，截图逻辑下面会处理）
    video.style.transform = (facingMode === "user") ? "scaleX(-1)" : "none";
  }catch(e){
    console.error(e);
    alert("无法打开相机：请检查权限；iOS 通常需要 https/localhost。");
  }
}

/**
 * 获取触摸/鼠标相对于页面的坐标
 * @param {PointerEvent} e - 事件对象
 * @returns {Object} 返回坐标 { x, y }
 */
function localPoint(e){
  const r = stage.getBoundingClientRect();
  const cx = e.clientX ?? e.touches?.[0]?.clientX;
  const cy = e.clientY ?? e.touches?.[0]?.clientY;
  return { x: cx - r.left, y: cy - r.top };
}

/**
 * 显示选区框
 * @param {Object} rect - 选区的矩形区域 {x, y, w, h}
 */
function showROI(rect){
  roiBox.style.display = "block";
  roiBox.style.left = rect.x + "px";
  roiBox.style.top  = rect.y + "px";
  roiBox.style.width  = rect.w + "px";
  roiBox.style.height = rect.h + "px";
}

/**
 * 隐藏选区框
 */
function hideROI() { roiBox.style.display = "none"; }

/**
 * 创建一个手指圆圈，用户用来标示触摸点
 * @param {number} x - 手指x坐标
 * @param {number} y - 手指y坐标
 * @returns {HTMLElement} 返回创建的手指圈元素
 */
function createFingerCircle(x, y) {
  const finger = document.createElement("div");
  finger.classList.add("finger");
  finger.style.left = `${x - 35}px`; // 确保圆圈居中
  finger.style.top = `${y - 35}px`; // 确保圆圈居中
  stage.appendChild(finger);
  return finger;
}

/**
 * 更新所有的手指圈显示
 * @param {TouchList} touches - 当前的触摸点列表
 */
function updateFingerCircles(touches) {
  fingers.forEach(finger => finger.remove());
  fingers = [];

  Array.from(touches).forEach(touch => {
    const { clientX, clientY } = touch;
    const finger = createFingerCircle(clientX, clientY);
    fingers.push(finger);
  });
}

/**
 * 旋转和缩放冻结区域的大小
 */
function updateFreezeSizeAndRotation() {
  freezes.forEach(freeze => {
    freeze.el.style.transform = `scale(${1 + (touchDistance / 200)}) rotate(${touchAngle}rad)`;
  });
}

/**
 * 绘制路径（自由绘制）
 */
function drawPath() {
  ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  path.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.closePath();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(255, 0, 0, 0)";
  ctx.lineCap = "round";
  ctx.stroke();
}

/**
 * 处理鼠标/触摸按下事件
 */
stage.addEventListener("pointerdown", (e) => {
  // 只在 stage 空白处开始框选（避免点到 topbar）
  if (e.target !== stage && e.target !== video && e.target !== roiBox) return;
  if (!video.srcObject) return;

  e.preventDefault();
  const p = localPoint(e);
  dragging = true;
  startPt = p;
  path = [p];
  showROI({ x:p.x, y:p.y, w:1, h:1 });
});

/**
 * 处理鼠标/触摸移动事件
 */
stage.addEventListener("pointermove", (e) => {
  if (!dragging || !startPt) return;
  e.preventDefault();
  const p = localPoint(e);
  path.push(p);
  const x = Math.min(startPt.x, p.x);
  const y = Math.min(startPt.y, p.y);
  const w = Math.abs(p.x - startPt.x);
  const h = Math.abs(p.y - startPt.y);
  roi = { x, y, w, h };
  showROI(roi);
  drawPath();
});

/**
 * 处理鼠标/触摸放开事件
 */
stage.addEventListener("pointerup", async (e) => {
  if (!dragging) return;
  e.preventDefault();
  dragging = false;

  if (path.length < 2) return;

  const rect = {
    x: Math.min(startPt.x, path[path.length - 1].x),
    y: Math.min(startPt.y, path[path.length - 1].y),
    w: Math.abs(path[path.length - 1].x - startPt.x),
    h: Math.abs(path[path.length - 1].y - startPt.y)
  };

  showROI(rect);
  await freezeROIToOverlay(rect);
  hideROI();
  path = [];
});

/**
 * 把框选的区域从视频中裁剪并显示在上面
 */
async function freezeROIToOverlay(cssRect){
  // 获取视频和stage的实际尺寸
  const vw = video.videoWidth;
  const vh = video.videoHeight;
  const sw = stage.clientWidth;
  const sh = stage.clientHeight;

  // 生成 overlay canvas，尺寸和 CSS 区域一致
  const overlay = document.createElement("canvas");
  overlay.className = "freeze";
  overlay.style.left = cssRect.x + "px";
  overlay.style.top  = cssRect.y + "px";
  overlay.style.width  = cssRect.w + "px";
  overlay.style.height = cssRect.h + "px";

  overlay.width = cssRect.w;
  overlay.height = cssRect.h;

  const ctx = overlay.getContext("2d");

  ctx.beginPath();
  ctx.moveTo(path[0].x - cssRect.x, path[0].y - cssRect.y);
  path.forEach(p => ctx.lineTo(p.x - cssRect.x, p.y - cssRect.y));
  ctx.closePath();
  ctx.clip();

  ctx.drawImage(
    video,
    (cssRect.x / sw) * vw, (cssRect.y / sh) * vh,
    (cssRect.w / sw) * vw, (cssRect.h / sh) * vh,
    0, 0, overlay.width, overlay.height
  );

  stage.appendChild(overlay);
  freezes.push({ el: overlay });

  // 如果后续需要做“冻结窗可拖动/可选中”，修改 pointer-events 和事件绑定即可。
}

/* =========================================================
   UI 按钮功能
========================================================= */

document.querySelector("#btnStart").addEventListener("click", startCamera);
document.querySelector("#btnFlip").addEventListener("click", async () => {
  facingMode = (facingMode === "environment") ? "user" : "environment";
  await startCamera();
});
document.querySelector("#btnUndo").addEventListener("click", () => {
  const last = freezes.pop();
  if (last?.el) last.el.remove();
});
document.querySelector("#btnClear").addEventListener("click", () => {
  freezes.forEach(f => f.el?.remove());
  freezes = [];
});
</script>
</body>
</html>
